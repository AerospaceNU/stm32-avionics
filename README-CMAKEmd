# Building Flight Software with CMake

CMake is a tool that allows us to generate build scripts in a nice, cross-platform way. We'll be using the compilers from [Arm GNU Toolchain](https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain), the same compiler that STM32CubeIDE uses, to compile code for our flight comtrol boards. Our processors are an AArch32 bare-metal (no operating system) target, so we want arm-none-eabi

Technical note: STM32 microcontrollers use a 32-bit Arm Cortex-based processor, while your computer is probably a 64-bit x86-based computer. That means we need to use a special compiler to build code for an Arm target from your laptop.

The valid targets that can be built are:
- fcb_v0
- fcb_v1
- fcb_v2
- groundstation
- amazon-stm32-arduino

## Linux setup

- Download the [Arm GNU Toolchain](https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain) that's right for your machine. I'm using a Linux x86_64 computer, so I'll download the arm-none-eabi version for a x86_64 Linux host.
- Extract the file to somewhere safe. I've put mine in `/home/matt/arm-gnu-toolchain-12.3.rel1-x86_64-arm-none-eabi`.
- Install cmake and a build tool like make with `sudo apt install cmake make`
- If you haven't yet, clone this repository as described in the [readme](/README.md)
- If the build directory within `stm32-avionics` already exists, delete its contents
- Open up a new terminal inside of stm32-avionics, and run:
```
cmake  \
  # Put build files into the build directory
  -B build \        
  # Build stm32 projects only
  -DPROJECT_BUILD_TYPE="stm32" \ 
  # Magic sauce to actually cross-compile
  -DCMAKE_TOOLCHAIN_FILE="cmake/stm32-cmake/cmake/stm32_gcc.cmake" \ 
  # Telling stm32-cmake where our C compiler is lets it find all the other tools (gcc, g++, strip, ld, etc)
  -DCMAKE_C_COMPILER=/PATH/TO/arm-gnu-toolchain-VERSION-x86_64-arm-none-eabi/bin/arm-none-eabi-gcc
```

## Windows setup

- Download the [Arm GNU Toolchain](https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain) that's right for your machine. I'm using a Windows computer, so I'll download the arm-none-eabi version for a Windows host.
- Extract the file to somewhere safe. I've put mine in `C:\Users\matth\Documents\arm-gnu-toolchain-12.3.rel1-x86_64-arm-none-eabi`.
- Install [CMake](https://cmake.org/install/) and [Ninja](https://github.com/ninja-build/ninja/releases). Make sure both end up on your PATH.

On Windows, I had to add `-DCMAKE_GENERATOR=Ninja` to the above, since I have MSVC installed, and its project generator refuses to cooperate with GNU compilers. I bet that mingw makefiles would also work as a generator. Also, I had to manually tell the cortex-debug extension where to find openocd, and I had to use the openocd from the line cutter repo (the one bundled with Cube couldn't find the st-link interface config??). I went into file->preferences->settings, searched for `cortex-debug.openocdPath.windows`, and set it to `D:/Downloads/openocd/OpenOCD-20210407-0.10.0/bin/openocd.exe` (this is probably different for you). Note the forward ticks (or double back slashes) -- Windows paths being backticks is dumb.

Windows:
```
cmake -B build -DPROJECT_BUILD_TYPE="stm32" -DCMAKE_C_COMPILER="C:\\Program Files (x86)\\Arm GNU Toolchain arm-none-eabi\\12.3 rel1\\bin" -DCMAKE_TOOLCHAIN_FILE="cmake/stm32-cmake/cmake/stm32_gcc.cmake" -DCMAKE_GENERATOR=Ninja
```

## Building code for a FCB

- Try building the `fcb_v0` code using:
```
cmake --build build --target fcb_v0 -- -j -l
```

We need to pass CMAKE_C_COMPILER since we look for gcc/g++/as/ld in the same folder as the GCC executable passed in. If you have the arm gnu toolchain already installed, by default, /usr/lib will be searched. Note that the toolchain from apt seems to produce larger binaries than the one that ships with Cube. I downloaded my toolchain from https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain , but you can also point it to the GCC from Cube.

Linux:
```
cmake -B build -DPROJECT_BUILD_TYPE="stm32" -DCMAKE_TOOLCHAIN_FILE="cmake/stm32-cmake/cmake/stm32_gcc.cmake" -DCMAKE_C_COMPILER=/home/matt/Documents/arm-gnu-toolchain-12.2.mpacbti-rel1-x86_64-arm-none-eabi/bin/arm-none-eabi-gcc
```

On Windows, I had to add `-DCMAKE_GENERATOR=Ninja` to the above, since I have MSVC installed, and its project generator refuses to cooperate with GNU compilers. I bet that mingw makefiles would also work as a generator. Also, I had to manually tell the cortex-debug extension where to find openocd, and I had to use the openocd from the line cutter repo (the one bundled with Cube couldn't find the st-link interface config??). I went into file->preferences->settings, searched for `cortex-debug.openocdPath.windows`, and set it to `D:/Downloads/openocd/OpenOCD-20210407-0.10.0/bin/openocd.exe` (this is probably different for you). Note the forward ticks (or double back slashes) -- Windows paths being backticks is dumb.

Windows:
```
cmake -B build -DPROJECT_BUILD_TYPE="stm32" -DCMAKE_C_COMPILER="D:\ST\STM32CubeIDE_1.4.0\STM32CubeIDE\plugins\com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.10.3-2021.10.win32_1.0.200.202301161003\tools\bin\arm-none-eabi-gcc.exe" -DCMAKE_TOOLCHAIN_FILE="cmake/stm32-cmake/cmake/stm32_gcc.cmake" -DCMAKE_GENERATOR=Ninja
```

We need to pass CMAKE_C_COMPILER since we look for gcc/g++/as/ld in the same folder as the GCC executable passed in. If you have the arm gnu toolchain already installed, by default, /usr/lib will be searched. Note that the toolchain from apt seems to produce larger binaries than the one that ships with Cube. I downloaded my toolchain from https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain , but you can also point it to the GCC from Cube.

Now, we can build the code for (say) FCB V0 with `cmake --build build --target fcb_v0`

